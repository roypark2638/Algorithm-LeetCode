# Algorithm-Leetcode

|  #  | Title  | Solution | Basic Idea |
| --- | ------------- | -------- | ------------ |
|  221  | [Convert Sorted Array To Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/LeetCode/ConvertSortedArrayToBinarySearchTree.py) | **Recursive BST construction: Time O(n) Space O(logn)**<br/> - Call a helper function with the nums array, start, and end index.<br/> - Use a binary search to pick the mid value and construct left and right subtrees.
|  220  | [Perfect Squares](https://leetcode.com/problems/perfect-squares/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/PerfectSquares.py) | **1. Memoization Recursion**<br/> We start from n to reach to base cases where n is less than 0 then return maximum int value, and if n is equal to the 0 then we return 0 as the current height.<br/> Create a variable height with a positive infinity value and a square with 1 for subtract each perfect square value.<br/> - While n is greater than 2 power of square, get the height of minimum of either returned recursion value with passing n - 2 power of square, or height. Increment square by 1.<br/> Store the the height result into memo map and return the height.<br/> **2. Tabulation: Time O(nm) Space O(n)**<br/> - Create an array consists of square numbers with perfect square numbers of less than n. For example, 1, 4, 9, 25, ..., sqrt(n)+1. Create a dp initially filled with maximum integer value size of n+1, and dp[0] to 0. dp table used to count the minimum of the perfect square numbers at i<br/> - Iterate i to n+1 times and also iterate square numbers array. Until the end of the square number or i is less than square number, update dp[i] to minimum of either dp[i] or dp[i-square]+1.
|  219  | [Maximal Square](https://leetcode.com/problems/maximal-square/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MaximalSquare.py) | **1. Bruth Force: Space O((nm)^2) Space O(nm)**<br/> **2. Tabultation: Time O(nm) Space O(nm)**<br/> - Create dp table with a size of (m+1) * (n+1) initially filled with 0s.<br/> - Iterate the matrix(0-indexed) from 1 to m+1 and n+1.<br/> If we found '1' in the matrix, then perform a recurrence relation dp[i][j] with a minimum value from the dp surrounding dp value(top, topleft, left) plus one, and also keep track of the maximum length.<br/> - return sqaured value of the maximum length.<br/> **3. Space Optimized from Tabulation: Time O(nm) Space O(m)**<br/> - Create 1-D dp array with a size of m+1, initially filled with 0s and prev valuable to keep track of previous(left) dp value.<br/> - Iterate matrix same as above and store current dp[j] value to temp variable to assign this later to prev variable after performing the recurrence relation.<br/> - if a current matrix has '1' then, perform a recurrence relation dp[j] with a minimum value from the dp[j-1], dp[j], and prev, also update the maximum length. If the current matrix is not '1', then, assign dp[j] to 0.<br/> - Now, we are done with recurrence relation, so assign temp value to prev variable.
|  218  | [Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/FindTheDuplicateNumber.py) | **1. Set: Time O(n) Space O(n)**<br/> - If we can modify the given array, we can simply use set to find the duplicate.<br/> **2. Mark As Negative Number in Mutable Array: Time O(n) Space O(1)**<br/> - If we can modify the given array, we can multiply the visited value with negative one and if we encounter a negative number during the iterations, that means that we found the duplicate value.<br/> **3. Floyd's Algorithm(Tortoise and Hare, cycle detection): Time O(n) Space O(1) in immutable array**<br/> - Use two pointers, slow and fast. Slow moves one element at a time and fast move two elements at a time. When both of the pointers meet at the first meeting point, we will move one pointer to the beginning of the starting point. <br/> - Now, we move both pointers by one element at a time. The second meeting point will be the first duplicate value, which the answer and the enterance of the cycle.
|  217  | [Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MergeTwoBinaryTrees.py) | **Recursive: Time O(n) Space O(n)** n is a maximum number of nodes between the two trees and for the space complexisty, average case would be logm which is the depth of the tree.<br/> - If both of the current nodes exist, then we sum up the node values into root1 node. <br/> Then assign the return node of recursion call traversing left subtrees result to the root1.left, and assign the return node of recursion call traversing right subtrees result to the root1.right. At the end of the recursion in this block, return root1, which we made changes and it will be reutnred to the root node of the left or right.<br/> - If either of the nodes have null values, simply return root1 or root2.
|  216  | [Flatten Binary Tree To Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/FlattenBinaryTreeToLinkedList.py) | **1. Recurisve DFS: Time O(n) Space O(n)**<br/>- Base case where current node is none return nothing, and where it's leaf node, return current node.<br/> - For a given node, we recursively flatten out the left and right subtrees and store their corresponding tail nodes in leftTail and rightTail respectively.<br/> - If there is a left child for the current node, conduct following reconnection. leftTail.right = node.right, node.right = node.left, node.left = null.<br/> - Next we have to return the tail of the final, flattened out tree rooted at node. So, if the node has a right child, then we will return the rightTail, else we return leftTail.<br/>**2. Morris Traversal: Time O(n) Space O(1) but slidely more time than recursive DFS.**<br/> - In a pre-order traversal of a binary tree, each vertex is processed in (node, left, right) order. This means that the netire left subtree could be placed between the node and its right subtree.<br/> - First, we need to locate the last right node in the left subtree while keeping track of the current node. So, whenever we find a left subtree, we can dispatch a runner(right most in one left from current), then stitch together both ends of the left subtree into the right path of current, takign head to sever the left connection at current.<br/> - Once that's done, we can continue to move current to teh right, looking for the next left subtree. When current can no longer move right, the tree will be successfully flattened.
|  215  | [Remove All Adjacent Duplicates In String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/RemoveAllAdjacentDuplicatesInString.py) | Use a stack to find the non-duplicate characters. Iterate the characters in the given string and store each character one by one, and check if current character is equal to the last element appended in the stack. If true, pop the last element. At the end of the loop, simply return the stack.<br/> Time O(n) Space O(n-d) where n is the length of string and d is total length for all duplicates.
|  214  | [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MinimumPathSum.py) | **1. Tabulation: Time O(nm) Space O(nm)**<br/> - Create a matrix same size as given grid.<br/> - Traverse grid i as row, j as colume.<br/> - Fill the index [0][0] with grid[0][0], and first row with a sum of current grid value and previous matrix value, and first colume with a sum of current grid value and previous matrix value. Lastly, all the other matrix value is a sum of current grid value and minimum of previous grid colume value or previous grid row value. <br/> **2. Space Optimized Tabulation By Mutating Given Grid.**<br/> - Instead of creating a new auxiliary data structure matrix, mutate given grid as we go, which will optimize space complexisty to constant value.<br/> **3. Memoization**<br/> In order to find the minimum path from the top left to the bottom right, we can use backtracking. Backtracking method syas that each and every cell has two methods, either right or down. So, the recursive solution will try all possible ways and the most optimal one return as an answer. <br/> Base cases are when i is equal to m and j is equal to n where i and j starts from 0 to n and m, and n is the length of grid row - 1, and m is the length of grid colume -1, which current grid value. If i is greater than m or j is greater than n return max infinity.<br/> Recurrence relation is a sum of current grid value and either minimum of mathPath(i+1, j) or mathPath(i,j+1).
|  213  | [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MinCostClimbingStairs.py) | **1. Tabulation**<br/> - Create an array, minCost with size as the length of cost array + 1, which holds a minimum cost to reach ith index.<br/> Iterate cost array from index 2 since we can take step either 1 or 2, which means reaching index 0 and 1 would cost 0.<br/> The recurrence replation to find ith minCost is the minimum cost of either minCost[i-1] + cost[i-1] or minCost[i-2] + cost[i-2].<br/> **2. Space Optimized Tabultaion: Time O(n) Space O(1)**<br/> Since we are only using two previous minCost values to get the current minimum cost, we can optimize space to constant space by using just two variables, downOne and downTwo.<br/> **3. Memoization**<br/> - Recursion will take length of cost (i) as an argument and work its way down to the base case where i is equal to 0 or 1 returning 0. <br/> The recurrence relation is same as tabulation. Minimum of either minCost(i-1, cost, memo) + cost[i-1] or minCost(i-2,cost, memo) + cost[i-2].
|  212  | [Dyanmic Programming Question Set](https://www.youtube.com/watch?v=oBt53YbR9Kk&ab_channel=freeCodeCamp.org)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/DPMemoizeAndTabultation.py) | ***Five hours*** of lecture from freeComeCamp.org including both Memoization and Talbulation approach for variaous questions. <br/>1. Fiboanacci <br/>2. GridTraveler <br/>3. CanSum <br/>4. HowSum <br/>5. BestSum <br/>6. CanConstruct <br/>7. AllConstruct
|  211  | [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ValidateBinarySerachTree.py) | - Traverse DFS manner and once we reach the leaf node check if it's valid.<br/> - While traversing the tree, keep track of the max and min bounds and check bounds on each.<br/> - If any node contains failed the bound check, return false.<br/> Time O(n) Space O(d)
|  210  | [Lowest Common Ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/LowestCommonAncestor.py) | **1. Recursive or Iterative solution Time O(n) Space O(n)**<br/> - Start traversing from the root node.<br/> - If the currNode is none return None<br/> - If the currNode itself is either p or q, return node itself.<br/> - Store left and right result into variables of recursion.<br/> - If left and right are both have nodes, then we found the LCA. Return node. Otherwise, return left or right.
|  209  | [Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/CountGoodNodesInBinaryTree.py) | **DFS inorder traverse Time O(n) Space O(d)**<br/> - Count the node where has greater value than any of the previous node values.<br/> - Create a dfs function with node and parentVal, where initial parentVal is -inf.<br/> - Traverse left and right subtree and keep count the number of count and update the parentVal on each iteration.
|  208  | [Path Sum III](https://leetcode.com/problems/path-sum-iii/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/PathSumIII.py) | **1. Bruth Force: Time O(n^2) Space O(n)**<br/> - Create global variable, count<br/> - 1st layer DFS, Use recurisve traverse to go through each node in any order manner<br/> - 2nd layer DFS, for each node, walk all path. If the pathSum is eqaul to the target, increment the count.<br/> **2. Memoization: Time O(n) Space O(n)**<br/> - Same as from previous question Subarray Sub Equals K, we create cache dictionary to count up the path.<br/> - One difference is after the left and right traverse, which is when we move to a different branch, the currPathSum is no longer available, hence remove one. cache[currPathSum] -= 1
|  207  | [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/SubarraySumEqualsK.py) | **1. Bruth Force: Time O(n^2) Space O(1)**<br/> - Use two loops to calculate currSum and if currSum is equal to the targetSum, increment the count. <br/> **2. Memoization of Path Sum: Time O(n) Space O(n)**<br/> - In order to optimize from the bruth force solution, we will have to think of a clear way to memoize the intermediate result.<br/> - Create a dictionary, cache to saves all the pathSum and their frequency. Loop through the array and we can get the currPathSum. If there exist a valid soltuion, there must be a oldPathSum such taht currPathSum - oldPathSum = targetSum.<br/> Add the frequency of the oldPathSum in the dictionary to the result.
|  206  | [Path Sum II](https://leetcode.com/problems/path-sum-ii/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/PathSumII.py) | **Binary Tree Recursive DFS.**<br/> - Base case 1. where node is none, return empty array.<br/> - Append the current node into the path and add up the currentSum.<br/> 2. If it's leaf node and the currentSum is equal to the targetSum, then append the path to the result array. Otherwise iterate left and right node.<br/> - Remove the last the element from the path array. <br/> Time O(n^2) for the worst case where the tree is complete tree and has n/2 number of leaf nodes. Copy operation takes extra n time complexsity verses, the best case is where the tree is leaner and has single node.<br/> Space O(n) to store the path.
|  205  | [Path Sum](https://leetcode.com/problems/path-sum/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/PathSum.py) | Binary Tree Recursive DFS and Iterative Solutions.<br/> **1. Recursive DFS**<br/> - Base case 1. where node is none, return False. 2. where it's leaf node and currentSum is equal to the targetSum, return True.<br/> - Compute left and right subtree and if that return value is true, then return true.<br/> **Time O(n) Space O(d)** where n is the number of the nodes in tree and d is the depth of the tree.<br/> **2. Iterative**<br/> - Initially store the root node and curerntSum(0) into a stack data structure.<br/> - While stack, if node is empty, simply continue next iteration.<br/> - Add up the currentSum and check if it's leaf node and currentSum is equal to the targetSum, return True. Otherwise, append child node from the currentNode and continue the iteration.<br/> **Time O(n) space O(d)**
|  204  | [Coin Change](https://leetcode.com/problems/coin-change/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/CoinChange.py) | Dynamic Programming Memoization and Tabulation.<br/> **1. Memoization**<br/> Base cases 1. where amount is eqaul to zero, retrun 0. 2. where amount is negative, return -1. <br/> - Create a minCount variable and on each iteration, get the returned value into count. If the count is eqaul to the -1, then simply continue to the next iteration. Otheriwse, update minCount = min(minCount, count+1)<br/>**Time O(nm) Space O(nm)**<br/> **2. Tabulation**<br/> Create a ways array filling with -infinity and the first index value is eqaul to 0.<br/> Iterate and if current coin is less than equal to the capacity, then update ways[i] = min(ways[i-coin]+1, waqys[i]).<br/> Return the value -1 if the last element of the ways is -infinity else last element.<br/> **Time O(nm) Space O(nm)**
|  203  | [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/PartitionEqualSubsetSum.py) | **Dyanmic Programming Memoization**<br/> - Calculate total sum of the array and get subsetTotal<br/> Recursively chec kwhether there exists a subset with target sum.<br/> There are three base cases. 1. where subsetTotal in memo dictionary. 2. where sum is equal to zero then return true. 3. where n == len(nums)-1 and subTotal is negative value.<br/> - Store the result of recursion call where one is including and another one is not including with or operation.<br/> **Time O(nm) Space O(nm)** where n is the length of the nums and m is the subTotal.
|  202  | [Best Time To Buy And Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/BestTimeToBuyAndSellStock.py) | - Calculate minValue and maxProfit on each iteration and itearte through the prices array.<br/> Time O(n) Space O(1)
|  201  | [Knapsack Problem](https://www.algoexpert.io/questions/Knapsack%20Problem)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/KnapsackProblem.py) | **Dynamic Programming Tabulation**<br/> - Create a matrix (m+1) x (n+1) to evaluldate the current maximum capacity<br/> - Iterate the matrix and if currentItemWeight is less than equal to the currentCapacity, then append eother maximum of currentItemValue + matrix[i][currentCapacity-currentItemWeight] or right above value into the current matrix. Otherwise, append above value.<br/> Finally return the sequence of the indices that creating the currentMamimumCapacity. <br/>**Time O(nm) space O(nm)** where n is the length of the items and m is the capacity.
|  200  | [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/LongestCommonSubsequence.py) | **Dynamic Programming Tabulation(Bottom-up)**<br/> **Time O(nm) Space O(nm)**
|  199  | [Course Schedule II](https://leetcode.com/problems/course-schedule-ii/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/CourseScheduleII.py) | **Topological Algorithm with DFS**<br/> Topological algorithm determines the ordering we should enroll in classes s.t. we never enroll courses which we do not have prerequisites for. Top algorithm is an ordering of the nodes in a directed graph where for each directed edge node A to node B, node A appears before node B in ordering. Note that top ordering are not unique list and directed graph containing a cycle cannot have top order. Therefore, Directed Acyclic Graph(DAG) is the only graph that can have top order. - Use color(1,2,3) to indicate current state and create stack structure to store topological orderings.<br/> **Time O(v+e) Space O(v+e)** where v is the number of vertex and e is the number of edges.
|  198  | [Course Schedule](https://leetcode.com/problems/course-schedule/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/CourseSchedule.py) | **1. Graph Traversal Backtracking**<br/> - Create a graph structure and adopt an adjacency list structure from the given course list.<br/> - Enumerate each node(course) in the constructed graph, to check if we could form a dependency cycle starting from the node.<br/> - Start checking the cycle via backtracking, where we breadcrumbs our path to detect visitied node. Also at the end of the each interation, remove the mark.<br/> **Time O(v^2+e)** where v is the vertex(number of courses) and e is the edge(number of dependencies).<br/> **2. Postorder Depth First Search.**<br/> - Add one more data structure from backtracking to check the processing node in stack. If we find a node that is in the process, we return False.<br/> **Time O(v+e) Space O(v+e)**
|  197  | [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MedianOfTwoSortedArray.py) | **Time O(logn) Space O(1)**<br/> Partition these two arrays into two halfs s.t. the number of elements on each side are exactly same and every element on left side is less than equal to every element on right side but if it's odd number than left side will have one more element.<br/> Check if maxLeftX <= minRightY and maxLeftY <= minRightX than calculate the median and return based on the the odd or even number of x+y. Otherwise move the high and low position accordingly.
|  196  | [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MergeTwoSortedLists.py) | **Recurisve Time O(n) Space O(n)**<br/> **Iterative Time O(n) Space O(1)**<br/> - Create a dummy node to keep track of the head.<br/> while l1 and l2 are not None, insert the smaller value node to the mergedList.<br/> After the while loop, insert the left over either l1 or l2 list to the mergedList and return dummy.next.
|  195  | [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ValidParentheses.py) | - Create an empty stack to keep track of parens and create hashmaps for parens mapping.<br/> - Iterate each value of given string and if char is open paren, then append to the stack, else check if closing paren is matching with the open paren, otherwise return false.<br/> return True if stack is empty at the end.<br/> **Time O(n) Space O(n)**
|  194  | [Reverse Integer](https://leetcode.com/problems/reverse-integer/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ReverseInteger.py) | - Keep track of a symbol as -1 or 1 to multiple at the end. <br/> - Convert x value to positive if it's negative<br/> Iterate until x == 0 and extract last digit fot each iteration by module of 10 and result value is eqaul to result * 10 for each iteration as well.<br/> - Return the value with multiple of symbol if result is in the bound pow(2,31) otherwise return 0.<br/> **Time O(n) Space O(1)**
|  193  | [Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/LongestCommonPrefix.py) | **Horizontal Comparison**<br/> Edge case 1. when len(strs) == 0: return ""<br/> - Hold first word and iterate rest of the words one by one.<br/> - Compare the each word char by char and find the min endPoint. <br/> Return the word[0:endPoint]<br/> Time O(n) space O(1) where n is the total number of characters from given strs array.
|  192  | [Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/FibonacciNumber.py) | **1. Recursion Time O(2^n) Space O(n)**<br/> **2. Memoize Recursion Time O(n) Space O(n)**<br/> **3. Iterative with Sliding Window Time O(n) Space O(1)**
|  191  | [Containger With Most Water](https://leetcode.com/problems/container-with-most-water/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ContainerWithMostWater.py) | The water area will always be limited by the height of the shorter line. Futher, the father the line, the more will be the water area obtained.<br/> Use two pointers, one at the beginning and one at the end.<br/> Calculate the water area and keep track of the most water area.<br/> Move shorter height line toward other end by one step<br/> **Time O(n) Space O(1)**
|  190  | [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/LongestPalindromicSubstring.py) | **1. Longest Common Substring** -> fails e.g. s=abdgfdcba<br/> **2. Bruth Force, Time O(n^3) Space O(1)**<br/> **Dyanmic Programming Time O(n^2) Space O(1)**<br/> - Check two conditions<br/> 1. s[i-1] and s[i+1]<br/> 2. s[i] and s[i+1]<br/> If it's palindrom, then expan both left and right to find the longest palindrome.
|  189  | [Find Leaves Of Binary Tree](https://leetcode.com/problems/find-leaves-of-binary-tree/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/FindLeavesOfBinaryTree.py) | **DFS and Hashmap**<br/> Key point here is to find and mark the height of each node.<br/> Use DFS to traverse the node and keep track of the currentHeight<br/> When we reach the base case, calculate currentHeight and store as follow<br/> hashmap{currentHeight: [node.val]}
|  188  | [Car Fleet](https://leetcode.com/problems/car-fleet/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/CarFleet.py) | - Create a data array of tuple to hole position and speed with the same index position<br/> - Sort that array based on the position in descending order because the cars are not allowed to pass a car in front. So we will start looking at the car positioned at the closest to the target.<br/> - If the arrival time to the target conflict with the previous car, than it's combined as one fleet. So if it's not conflict, then we will count the number of fleet. In order to do that, keep track of the previousFinishTime. If previousFinishTime is smaller than currentFinishTime than update the previousFinishTime and increment fleet. It means that a car behind couldn't catch up the car in front, so it's arrived seperately.<br/> **Time O(nlogn) Space O(n)**
|  187  | [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/LetterCombinationsOfPhoneNumber.py) | **Recursive Backgracking with Hashmap**<br/> - Base case, i.e. to terminate the recursion is when len(currentString) == len(digits)<br/> - Get the letters that the current digit maps to, and loop through them<br/> Add the letter to our currentString, move on to the next digit, and backtrack by removing the letter before moving onto the next.<br/> **Time O(4^n * n) Space O(n)** where n is the legth of digits.
|  186  | [Minimum Number of Vertices to Reach All Nodes](https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MinimumNumberOfVerticesToReachAllNodes.py) | Track of all the vertices from which we start traversing, and if we found vertex which is already in result set and reached by other vertex then we will remove it from result set because vertex and all the vertices that can be reached from that vertex can also be reached from other vertex.<br/> **Time O(n) Space O(n)** n is number of the edges.
|  185  | [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/SwapNodesInPairs.py) | **Recursive Backgrack**<br/> - Base case, i.e. the moment to terminate the recursion is when head or head.next is pointing to Null.<br/> - Store nodes to be swapped and swap then return the new head<br/> **Time O(n) Space O(n)**<br/> Iterative soltuion, we swpa the node as we go through the nodes.<br/> Time O(n) Space O(1)
|  184  | [All Paths From Source To Target](https://leetcode.com/problems/all-paths-from-source-to-target/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/AllPathsFromSourceToTarget.py) | **Directed Acyclic Graph(DAG) backgrack**<br/> - Baes case, i.e. the moment to terminate the recursion is when currNode == len(graph)-1<br/> Iterate all neighbor nodes and mark the choice by appending the nieghbor node to the path on each iteration.<br/> - Then invoke backgrack() recursive function to explore deeper.<br/> **Time O(2^n * n) Space O(2^n * n)**
|  183  | [My Calendar I](https://leetcode.com/problems/my-calendar-i/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MyCalendarI.py) | 1. Binary Search Tree structure<br/>- Find the correct index of the interval<br/>- Make sure that the left and right intervals don't intersect<br/>Time O(logn) Space O(h)
|  182  | [Zigzag Conversion](https://leetcode.com/problems/zigzag-conversion/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ZigZagConversion.py) | - **1. Read Zigzag row.**<br> Base condition: if numRow is less than equal to 1, return original string<br/> - Increment the pointer to find the correct position to append<br/> - First and last row has one jump, in other words, it has one element to append<br/> - All the other rows in between first and last have two elements to append<br/> - Increment value can be calculated by (numRows - 1) * 2<br/> - Increment value in between first and last can be calculated by (increment + currentPosition - (2 * currentRow)) -> and make sure to check the bounds<br/> **2. Create an empty string array with the number of rows and read each char in s and append to corresponding index.<br/> Time O(n) Space O(n)**
|  181  | [Shortest Diatnace To Target Color](https://leetcode.com/problems/shortest-distance-to-target-color/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ShortestDistanceToTargetColor.py) | **1. Burth-Force**<br/> - Iterate queries enumerate(i, color)<br/> - Call getShortestDistance function to iterate leftSubarray and rightSubarray to calculate shortest distance to the color, if there is no color than return -1, or return the shortest distance index<br/> - append the shortest distance index<br/> **2. Hashmap with Binary Search**<br/> - Create hashMap {color: [index]}<br/> - Iterate queries and get the shortest distance<br/> - Find the color and call binary search to find the index where can insert number<br/> - Calculate the shortestDistance on current, left, and right
|  180  | [Alphabet Board Path](https://leetcode.com/problems/alphabet-board-path/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/AlphabetBoardPath.py) | **1. Hashmap and an array**<br/> - Create a hashmap where alphabet as a key and (r,c) position as a value with loop<br/> - iterate char in given target string<br/> - Call movePositionAndUpdateString function where take currentIndex and targetIndex as arguments<br/> - Calculate movements(ups, lefts, rights, downs) and add the number of "U","L","R","D" char * movements<br/> - append "!" at the end<br/> return that string<br/> - Add the returned string to the result
|  179  | [Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MaximumBinaryTree.py) | - No duplicates, if there is a duplicate, we can use the first occured value since the array is not sorted but ask to the interviewer for the confirmation of their thoughts<br/>- Find index of the maximum value in nums array<br/>- Create a new node to insert with the max value from the array<br/>- Slice the nums into leftSubarray and rightSubarray<br/>The first largest number is the root node where we start<br/>[3,2,1,6,0,5]<br/> ------p---- <br/> [0,5] right<br/>---p<br/>[0] left<br/>-p-<br/>[3,2,1] left<br/>-p---<br/>[2,1] right<br/>-p--<br/>[1] right<br/>-p-
|  178  | [High Five](https://leetcode.com/problems/high-five/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/HighFive.py) | **1. Hashmap with Array**<br/> - create hashmap to store id as a key and scores as value of an array.<br/> - Sort each array of the scores in descending order<br/> Store result in an array with id and average of the top five scores.<br/>**Time O(nlogn) Space O(n)**
|  177  | [Quick Sort](https://www.algoexpert.io/questions/Quick%20Sort)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/QuickSort.py) | - Pick a pivot number on left, right, or random.<br/> - Iterate rest of the array and sort numbers with respect to the pivot value.<br/>Time Worst O(n^2) when every iteration keeps dividing subarrays one with largest and antoher slide is smallest.<br/> **Time Best O(nlogn)** When every iteration divides subarray exactly half.<br/> **Average Time O(nlogn)**<br/> **Space O(logn)** In the recursion, it requires to apply the Quick Sort technicque first on the smallest of the two subarrays.
|  176  | [Employee Free Time](https://leetcode.com/problems/employee-free-time/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/EmployeeFreeTime.py) | - Sort the intervals by starting time<br/> - Merge the busy overlapping time(same as a merge interval question)<br/> - Find differences between merged[i-1].end and merge[i].start for every employees to have common free time.
|  175  | [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MeetingRoomsII.py) | **1. Hashmap key as the meeting room and value as an array of intervals.**<br/> **Time O(n + w * logn) Space O(n)** where n is the legnth of the intervals and w is the number of min meeting rooms<br/> 2. **Optimal**<br/> Checking how many meetings begin before the earliest ended meeting ends. For example, if 3 meetings have started before the earliest possible meeting end, than we need 3 rooms. Sorting helps in two things.<br/> - Find what's the earliest meeting ends time<br/> - It allows you to start looking for meetings ends only from next element in the ends array when you find some meeting start that is after the current end, because all other meeting ends before the current in the sorted array will also be before the current meeting start. So you just have to run 1 time over each array.<br/> **Time O(nlogn) Space O(n)** where n is the length of the intervals.
|  174  | [Minimum Difference Between Largest and Smallest Value in Three Moves](https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MinimumDifferenceBetweenLargestAndSmallestValueInThreeMoves.py) | - First sort the given nums<br/>- Let's say k is the number of moves that we can do<br/>- And for this specific question, the k is 4 for 3 moves(0, 1, 2, 3)<br/>- If the len of nums is <= k(4) then we can return 0<br/>- We have 4 plans<br/>1. nums[-4] - nums[0] -> remove 3 smallest<br/>2. nums[-3] - nums[1] -> remove 2 smallest and 1 largest<br/>3. nums[-2] - nums[2] -> remove 1 smallest and 2 largest<br/>4. nums[-1] - nums[3] -> remove 3 largest
|  173  | [Logger Rate Limiter](https://leetcode.com/problems/logger-rate-limiter/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/LoggerRateLimiter.py) | **1. One Hashmap (Simpler but disadvantage of managing growing memory**<br/> **2. Two Hashmap can manage the memory usage**<br/> latest is last time that cacheNew is created(and first log inserted at the same time). We don't insert message into cacheOld.<br/> - All of the messages in cacheOld have older timestamp than latest.<br/> - All of the messages in cacheNew have newer timestamp than latest, but older timestamp than latest + 10.<br/> We compare the current timestamp with latest,<br/> - If timestamp >= lastest + 20, then all messages in both cacheNew and cacheOld have older timestamp than timestamp - 10, we can clean them all.<br/> - If timestamp >= latest + 10, then all messages in cacheOld have older timestamp than timestamp - 10, we can clean messages in cacheOld.<br/> - Otherwise, we need to check if either cacheNew or cacheOld contains the message.
|  172  | [Integer To Roman](https://leetcode.com/problems/integer-to-roman/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/IntegerToRoman.py) | **Greedy with Hashmap**<br/> The roman numeral is consisted with largest possible symbols, working from the left. Therefore, we use a greedy algorithm to choose the best possible decision at the current time; in this case taking out the largest possible symbol at each iteration.<br/>- Create a hashmap as {index:[romanChar, value]}<br/>- While the num is not equal to 0, subtract the largest roman value possible and append the roman character to the final result string.<br/>**Time O(1) Space O(1)**
|  171  | [Roman To Integer](https://leetcode.com/problems/roman-to-integer/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/RomanToInteger.py) | **Hashmap Left-To-Right Pass**<br/>- Create a hashmap for the roman to integer value.<br/>- Two condition either current roman character is a special character with a consist of two characters or a one roman character.<br/>**Time O(1) Space O(1)**
|  170  | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/LongestSubstringWithoutRepeatingCharacters.py) | **Use hashmap to store each character as a key and its index to a value as a pair.** Also, we will keep track of the longestLengthOfSubstring and currentStartingIndex. Enumerate the given string and store the current character and the index to the hashmap. If we detect a repeated character, then we will update currentStartingIndex with either maximum of a index from the detected character from hashmap + 1 or currentStartingIndex. The reason why we update the currentStartingIndex is because we want to start a new count at a point where doesn't have a repeated character. However, in order to know what's our maximum length for a result, on each iteration we need to update the the longestLengthOfSubstring with a maximum of either longestLengthOfSubstring or currentIndex - currentStartingIndex + 1.
|  169  | [Number of Islands](https://leetcode.com/problems/number-of-islands/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/NumberOfIslands.py) | **Iterative DFS with queue structure**<br/> - This method directly mutate grid to mark for visiting<br/> - If mutation is not allowed, create a new matrix to check the visiting<br/>**Time O(n * m) Space O(n * m)**
|  168  | [Build Array From Permutation](https://leetcode.com/problems/build-array-from-permutation/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/BuildArrayFromPermutation.py) | - Create an array with None value with the length if nums array<br/> - Iterate value in nums and assign the value by using ans[i] = nums[nums[i]]
|  167  | [Binary Search Tree To Greater Sum Tree](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/BinarySearchTreeToGreaterSumTree.py) | Time O(n) Space O(h)
|  166  | [Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/RangeSumOfBST.py) | **Iterative DFS<br/> Time O(n) Space O(n)**
|  165  | [Sum of Nodes With Even-valued Grandparent](https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/SumOfNodesWithEvenValuedGrandparent.py) | **1. DFS Iterative and add grandchild value<br/> 2. DFS iterative, check parent and add currNode value<br/> 3. DFS recurisve**
|  164  | [Find Corresponding Node Of Binary Tree in Clone of That Tree](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/FindCorrespondingNodeOfBinaryTreeInCloneOfThatTree.py) | Find and store the target node from original<br/> And find the node from cloned
|  163  | [Deepest Leaves Sum](https://leetcode.com/problems/deepest-leaves-sum/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/DeepestLeavesSum.py) | **1. DFS inorder traversal, stack and iteratively<br/>Time O(v+e) Space O(d)<br/> 2. BFS, queue and iteratively**
|  162  | [Flipping an Image](https://leetcode.com/problems/flipping-an-image/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/FlippingAnImage.py) | **1. bruth force and two pointers<br/>- swap the value at each row(reverse row)<br/> - invert 0 to 1 and 1 to 0<br/>Time O(nm) Space O(1)**
|  161  | [Reverse String](https://leetcode.com/problems/reverse-string/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ReverseString.py) | **1. Recursion<br/> Time O(n) Space O(n)<br/> 2. Two pointers<br/> Time O(n) Space O(1)**
|  160  | [Reverse Prefix Of Word](https://leetcode.com/problems/reverse-prefix-of-word/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ReversePrefixOfWord.py) | **1. Pointer<br/> - Iterate word with enumerate and find the index of given ch.<br/> - Reverse word by slicing and return the result.**
|  159  | [Minimize Maximum Pair Sum in Array](https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MinimizeMaximumPairSumInArray.py) | **1. Sort and two pointers<br/> Time O(nlogn) Space O(1)**
|  158  | [Dot Product of Two Sparse Vectors](https://leetcode.com/problems/dot-product-of-two-sparse-vectors/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/DotProductOfTwoSparesVectors.py) | Spare Vector is a vector that has mostly zero values, while a dense vector is a vector where most of the elements are non-zero. It's ineifficient to store a sparese vector as a one-dimentioanl array. Instead, we can store the non-zero values and their corresponding indices in a dictionary, with the index being the key.
|  157  | [Print Immutable Linked List in Reverse](https://leetcode.com/problems/print-immutable-linked-list-in-reverse/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/PrintImmutableLinkedListInReverse.py) | **1. Recursion<br/> Time O(n) Space O(n)<br/> 2. Divide and conquer<br/> Time O(nlogn) Space O(logn)<br/> 3. Two pointers, print from the back<br/> Time O(n^2) Space O(1)**
|  156  | [Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/PeakIndexInAMountainArray.py) | **1. Bruth force<br/> Time O(n) space O(1)<br/> 2. Binary search<br/> Time O(logn) Space O(1)**
|  155  | [The K Weakest Rows in a Matrix](https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/TheKWeakestRowsInAMatrix.py) | **1. Linear searching and sorting**<br/> - Calculate Strengths and store in a tuple of strength and index.<br/> - Sort the tuple and return the indices.<br/> **Time O(nm) + O(mlogm) = O(m * (n + logm)) Space O(m)**<br/> **2. Binary searching and sorting/map**<br/> - Find the number of 1s with binary search and same process from the above.<br/> **Time O(m * (n + logm)) Space O(m)**
|  154  | [Count Negative Numbers in a Sorted Matrix](https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/CountNegativeNumbersInASortedMatrix.py) | **1. Bruth Force.**<br/> - Count all the negatives and return the count. <br/>**Time O(nm) Space O(1)**<br/> **2. Take advantage of the fact that it's sorted in non-increasing order.**<br/> - Staircase. Start from left bottom and count the negatives. <br/>**Time O(nm) Space O(1)**
|  153  | [Find Smallest Common Element in All Rows](https://leetcode.com/problems/find-smallest-common-element-in-all-rows/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/FindSmallestCommonElementInAllRows.py) | **1. Bruth-Force Hashmap <br/> 2. Binary Search**
|  152  | [Intersection of Three Sorted Arrays](https://leetcode.com/problems/intersection-of-three-sorted-arrays/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/IntersectionOfThreeSortedArrays.py) | **1. Binary Search Time O(nlogn) Space O(logn)<br/> 2. Bruth-Force HashMap Time O(n) Space O(n)<br/> 3. Three Pointers Time O(n) Space O(1)**
|  151  | [Remove Kth Node From End](https://www.algoexpert.io/questions/Remove%20Kth%20Node%20From%20End)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/RemoveKthNodeFromEnd.py) | - Create 2 pointers, first and second.<br/> - Move second pointer to kth times<br/> - And move both of pointers until second is pointing to None<br/> - Now remove the node where first pointer is pointing to<br/> Time O(n) Space O(1).
|  150  | [Valid Starting City](https://www.algoexpert.io/questions/Valid%20Starting%20City)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ValidStartingCity.py) | **Greedy Algorithm: Time O(n) Space O(1)**<br/> - Keep track of minGas and minCity.<br/> - Calculate milesLeft on each city and returns the city where has a minimum milesLeft.
|  149  | [Task Assignment](https://www.algoexpert.io/questions/Task%20Assignment)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/TaskAssignment.py) | **Greedy Algorthim: Time O(nlogn) Space O(n)**<br/> - Create a dictionary with an array as a value holding indicies.<br/> - Sort the given tasks and iterate k times
|  148  | [Minimum Passes Of Matrix](https://www.algoexpert.io/questions/Minimum%20Passes%20Of%20Matrix)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MinimumPassesOfMatrix.py) | **Find positive value index**<br/> - From that index, find and update neighbors where has negative values. <br/> - Keep those updated neighbors for the next queue to update.<br/> **Time O(w * h) SpaceO(w * h)**
|  147  | [Disk Stacking](https://www.algoexpert.io/questions/Disk%20Stacking)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/DiskStacking.py) | **Dyanmic Programming: Time O(n^2) Space O(n)**<br/> - Sort the disks by height and keep track of the tallest heights on each index<br/> - Use two for-in loop to find stackable disks and store the heights and sequences.
|  146  | [Reverse Linked List](https://www.algoexpert.io/questions/Reverse%20Linked%20List)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ReverseLinkedList.py) | **Create 3 pointers. prev, curr, and next. <br/> Time O(n) Space O(1)**
|  145  | [Remove Islands](https://www.algoexpert.io/questions/Remove%20Islands)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/RemoveIslands.py) | Iterate the edges of the matrix and mark all of the connected 1s by converting it to the 2<br/> - Iterate the entire matrix and change left 1s to the 0 and 2s to the 1<br/> **Time O(wh) Space O(wh)** width and height.
|  144  | [First Non-Repeating Character](https://www.algoexpert.io/questions/First%20Non-Repeating%20Character)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/FirstNon-RepeatingCharacter.py) | - Create a frequency table for each char in string.<br/> - And iterate string index and compare to the frequency table.<br/> - If the frequency value is equal to 1, return the current index.<br/> **Time O(n) Space O(1)** Space is constant because lowercase English alphabet letters are constant.
|  143  | [Selection Sort](https://www.algoexpert.io/questions/Selection%20Sort)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/SelectionSort.py) | **Divide into two sections into sorted and unsorted.** <br/> - Find the smallestIndex and at the end of each iteration, swap the value to the left. <br/>**Time O(n^2) Space O(1)**
|  142  | [Insertion Sort](https://www.algoexpert.io/questions/Insertion%20Sort)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/InsertionSort.py) | **Time O(n^2) Space O(1)**
|  141  | [Bubble Sort](https://www.algoexpert.io/questions/Bubble%20Sort)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/BubbleSort.py) | - i, j pointer moves together until j < len(array) - i<br/> - Check if there is a change happended each loop, if not, break and return.<br/> Time O(n^2) Space O(1).
|  140  | [Youngest Common Ancestor](https://www.algoexpert.io/questions/Youngest%20Common%20Ancestor)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/YoungestCommonAncestor.py) | - Given two descendatns have different level in the tree<br/> - In order to find the common ancestor, we need to make those two decendants at the same level.<br/> - Calculate both of depth in the tree and move lower decendant to the same level of higher decendant.<br/> - Now, two decendants are at the same level.<br/> - Move both of decendants until they are pointing to the same node.
|  139  | [River Sizes](https://www.algoexpert.io/questions/River%20Sizes)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/RiverSizes.py) | - Create an array to hold the result sizes<br/> - Copy the matrix and assign initial value of False to mark if we visited or not<br/> - Use two for loops<br/> - If visited, then continue, otherwise call traverseNode function<br/> - Use BFS and queue to traverse the adjacent nodes<br/> - Check if current position's status is true or not, if yes, continue, if not then set the current position's visit status True<br/> - getUnvisitiedNeighbors and append those neighbors to the queue<br/> - If currentRiverSize > 0, then append that into the result sizes array.
|  138  | [Breath-first Search](https://www.algoexpert.io/questions/Breadth-first%20Search)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/Breadth-firstSearch.py) | **Time O(v + e) Space O(v)**<br/> Use a queue data structure.
|  137  | [Single Cycle Check](https://www.algoexpert.io/questions/Single%20Cycle%20Check)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/SingleCycleCheck.py) | - Handle the index that exceed the len(array)<br/> - Handle a negative index <br/> While we're iterating the array, if we come back to the starting index, we know it fails the condition.<br/> **Time O(n) Space O(1)**
|  136  | [Kadane's Algorithm](https://www.algoexpert.io/questions/Kadane's%20Algorithm)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/KadanesAlgorithm.py) | **Dynamic Programming**<br/> **Kadane's algorithm** is used to find the maxmimum adjacent sum in the given integer array including negative values. **Time O(n) Space O(1)**<br/> - Keep track of two variables, currentMaxEnding and maxSoFar.
|  135  | [Levenshtein Distance](https://www.algoexpert.io/questions/Levenshtein%20Distance)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/LevenshteinDistance.py) | **Dynaimc Programming**<br/> Solution 1<br/> - Create two dimentional array size of (n+1) * (m+1) to keep track of the minimum editions. Time O(nm) Space O(nm) where n is the length of str1 and m is the length of the str2<br/>Optimal Solution<br/> - Create only two smaller length of rows to keep track the minimum editions. **Time O(nm) Space O(min(n, m)).**
|  134  | [Min Number Of Coins For Chnage](https://www.algoexpert.io/questions/Min%20Number%20Of%20Coins%20For%20Change)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MinNumberOfCoinsForChange.py) | **Dynaimc Programming**<br/> - Create an array with Nth number filled with float("inf") in Python and set array[0] = 0.<br/> - Each array position represetns the minimum number of ways to make the given change and we will build it with each iteration of denoms.<br/> **Time O(nd)** where n is the given target amount and d is the number of elements in denoms array. <br/> **Space O(n).**
|  133  | [Number Of Ways To Make Change](https://www.algoexpert.io/questions/Number%20Of%20Ways%20To%20Make%20Change)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/NumberOfWaysToMakeChange.py) | **Dynamic Programming**<br/> - Create an array with Nth number filled with 0 and set array[0] = 1<br/> - Each array position represents the number of ways to make the change and we will build with each iteration of denoms.<br/> If denom <= ways: then ways[amount] += ways[amount - denom]<br/> **Time O(nd)** where n is the given target amount and d is the number of elements in denoms array.<br/> **Space O(n).**
|  132  | [Max Subset Sum No Adjacent](https://www.algoexpert.io/questions/Max%20Subset%20Sum%20No%20Adjacent)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MaxSubsetSumNoAdjacent.py) | **Dynamic Programming solution**<br/> 1. Using a new array space solution **Time O(n) Space O(n)**<br/> 2. Using two temp variables first, second to keep track of current sum. <br/> - Optimal Solution **Time O(n) Space O(1).**
|  131  | [Invert Binary Tree](https://www.algoexpert.io/questions/Invert%20Binary%20Tree)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/InvertBinaryTree.py) |**1. Breath First Search (Iterative Solution) Time O(n) Space O(n)**<br/> 2. Recursive Solution <br/> - **Time O(n)** where n is the number of the nodes in the tree<br/> - **Space O(d)** where d is the depth of the tree.
|  130  | [Min Height BST](https://www.algoexpert.io/questions/Min%20Height%20BST)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MinHeightBST.py) | Either write a function by using given insert method -> **Time O(nlogn) Space O(n)**<br/> Or write a function manually constrcuting the min height bst with given sorted array consisting of distinct integers -> **Time O(n) Space O(n).**
|  129  | [BST Traversal](https://www.algoexpert.io/questions/BST%20Traversal)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/BSTTraversal.py) | Use **recursion to create inOrderTraverse, preOrderTraverse, and postOrderTraverse. Time O(n) and Space O(n)** where n is the number of the nodes in the BST.
|  128  | [Validate BST](https://www.algoexpert.io/questions/Validate%20BST)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ValidateBST.py) | Use **recursion, divide and conquer algorithm. Find out if each subtree is valid BST. Time O(n) and Space O(d)** where n is the number of the nodes and d is the depth of the tree.
|  127  | [BST Construction](https://www.algoexpert.io/questions/BST%20Construction)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/BSTContruction.py) | insert, contains, and remove methods
|  126  | [Merge Overlapping Intervals](https://www.algoexpert.io/questions/Merge%20Overlapping%20Intervals)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/mergeOverlappingIntervals.py) | - Sort the array based on the startInterval in the given intervals array<br/> - Create a mergedIntervals array to store the result, and append the first interval from the sorted intervals<br/> - Iterate range from 1 to end of the array<br/>  - - Get the currentStartInterval and previousEndInterval value<br/> - - If currentStart is less than or equal to the previousEndInterval<br/> - - - True, update the mergedIntervals's last interval's endInterval to max value of sortedInterval end or mergedIntervals end<br/> - - - False, append the sortedIntervals to mergedIntervals<br/> - return mergedIntervals as the result
|  125  | [First Duplicate Value](https://www.algoexpert.io/questions/First%20Duplicate%20Value)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/FirstDuplicateValue.py) | **1. HashMap Time O(n) Space O(n)**<br/> - Create a hashmap to store the value that we found and mark it.<br/> - Iterate the array and check if the value exist in our hashmap.<br/><br/> **2. Array Munipulation Time O(n) SpaceO(1)**<br/> - Since the given prompt indicates that an array of integers between 1 and n, inclusive, where n is the length of the array and we can mutate the given array, we can use this method.<br/> - Iterate array and create seenIndex by abs(value) - 1 to mark by negative value the found value on that index.<br/> - If the value from seenIndex is negative, return that abs(value).
|  124  | [Array Of Products](https://www.algoexpert.io/questions/Array%20Of%20Products)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ArrayOfProducts.py) | - Create a new array with value 1 on each position<br/> - Use for-in loop to store a current leftRunningProduct value into the new array products<br/> - Use another for-in loop to multiple the current products[i] with a current rightRunningProduct value into products array.<br/> - Return products array as the result.
|  123  | [Longest Peak](https://www.algoexpert.io/questions/Longest%20Peak)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/LongestPeak.py) | - Start from index 1 and check if current position is a peak<br/> - If it's a peak then calculate left and right length to find currentPeakLength<br/> - Update the longestPeakLength if currentPeakLength is greater<br/> - Update index to right pointer.
|  122  | [Spiral Traverse](https://www.algoexpert.io/questions/Spiral%20Traverse)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/SpiralTraverse.py) | **Time O(n) and Space O(n)** where n is the total number of the two dimential array elements.
|  121  | [Monotonic Array](https://www.algoexpert.io/questions/Monotonic%20Array)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MonotonicArray.py) | 1. check if len(array) <= 2, then return true.<br/>2. get first direction by array[1] - array[0].<br/>3. loop through the array from range 2.<br/>  4. check if the direction is meaningful(if direction == 0, then update the direction by array[i] - array[i-1].<br/>  5. check if current direction is broken from previous direction then return False. Otherwise return True.
|  120  | [Move Element To End](https://www.algoexpert.io/questions/Move%20Element%20To%20End)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ElementToEnd.py) | 1. Use left and right pointers.<br/>2. While left < right<br/>3. while left < right and left value is not toMove value update the left and while left < right and array[right] is equal to toMove value, update the right pointer. <br/>Swap the values.
|  119  | [Smallest Difference](https://www.algoexpert.io/questions/Smallest%20Difference)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/SmallestDifference.py) | Use two pointers to compare the difference. Keep track of smallest and current differences. Loop while any of them doesn't exceed their array index. Keep track of a current difference and check if smallest > current than, update the smallest variable.
|  118  | [Permutations](https://leetcode.com/problems/permutations/)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/Permutations.py) | **Time O(n!n) Space O(n!)** Building permutation takes n! time and space complexisity. If we think about building a set of permutations where the n is 3, at our first position we have the n number of cases. For next position we take away 1. Now we have n-1: 2 number of cases. Finally we take away 1 more and we have 1 number of cases left. For the time complxisty at each iteration we also have a copy operation, which take another n time complexisty.<br/> - We will call a recursion function named constructPerms with nums, current perm, len(nums), and result array permutations. <br/> - When the current permutation's length is equal to the length of the given nums array, we want to append the permutation into the final array. <br/> - Iterate the nums array in the recursion and append the current number into the current perm and build a new number array with the left side and right side of the numbers from current given number, and call the recursion function with the new number array. At each end of the iteration of recursion, we want to make sure to pop the perm so that it doesn't carry previous numbers.
|  117  | [Palindrome Check](https://www.algoexpert.io/questions/Palindrome%20Check)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/PalindromeCheck.py) | 1. Create two pointers, one on the left and one on the right. <br/>2. While left < right: check if the char is the same or not. If it's not same, return False. Otherwise, increment both of the pointers.
|  116  | [Find Three Laregest Numbers](https://www.algoexpert.io/questions/Find%20Three%20Largest%20Numbers)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/FindThreeLargestNumbers.py) | **Time: O(n) and Space: O(1)**<br/>Set a result array with 3 given array values and sort it. and iterate rest of the array and swap the values depends on large numbers.
|  115  | [Binary Search](https://www.algoexpert.io/questions/Binary%20Search)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/BinarySearch.py)  | Use 3 pointers, left, right, mid.<br/>1. left = 0<br/>2. right = len(array) - 1<br/>3. mid = (left + right) // 2<br/>Iterate the sorted array and find the target with 3 pointers.
|  114  | [Nth Fibonacci](https://www.algoexpert.io/questions/Nth%20Fibonacci)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/NthFibonacci/main.py)  | Create a temp array to hold two values, lastTwo = [0,1]. And update the value.<br/>lastTwo[1] = lastTwo[0] + lastTwo[1] <br/>lastTwo[0] = lastTwo[1]
|  113  | [Remove Duplicates From Linked List](https://www.algoexpert.io/questions/Remove%20Duplicates%20From%20Linked%20List)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/RemoveDuplicatesFromLinkedList/main.py)  | Start from the head and check if nextDistinctNode.value is not none and equal to currentNode.value, if yes, then keep move the nextDistinctNode to next and finally move currentNode pointer to the nextDistinctNode to remove duplicates until we reach the end of the sorted singly linked list.
|  112  | [Tandem Bicycle](https://www.algoexpert.io/questions/Tandem%20Bicycle)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/TandemBicycle/main.py)  | 1. Sort the speeds based on fastest value<br/>2. iterate through speeds array and add up the max speeds
|  111  | [Class Photo](https://www.algoexpert.io/questions/Class%20Photos)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ClassPhotos/main.py)  | 1. Sort the array in reverse order<br/>2. Find the group where has tallest student and place that color student group to back row<br/>3. Compare each value in the array if back row students are strictly greater than front row students
|  110  | [Minimum Waiting Time](https://www.algoexpert.io/questions/Minimum%20Waiting%20Time)  | [Python](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MinimumWaitingTime/main.py)  | 1. Sort the array<br/>2. Create two variables waitingTime, minimumTotal<br/>3. Iterate array<br/>- 4. MinimumTotal += waitingTime<br/>- 5. WaitingTime += n|
|  109  | [Merge Overlapping Intervals](https://www.algoexpert.io/questions/Merge%20Overlapping%20Intervals)  | [Swift](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MergeOverlappingIntervals.playground/Contents.swift)  | 1. Sort by start time<br/>2. Create an empty mergedIntervals for result<br/>3. Create currentInterval variable<br/>4. Insert first interval into the result array<br/>5. Loop the intervals.<br/>- 6. Get currentIntervalEnd, nextIntervalStart and nextIntervalEnd<br/>- 7. If overlapping -> get the max from currentEnd & nextEnd and update existing merged result array.<br/>- 8. if not overlapping -> assign nextInterval to currentInterval and append the updated currentInterval to the result array|
|  108  | [Three Number Sum](https://www.algoexpert.io/questions/Three%20Number%20Sum)  | [Swift](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ThreeNumberSum.playground/Contents.swift)  | 1. Sort given array<br/>2. Create an empty triplets array<br/>3. for pivot in 0..<array.count-2<br/>- 4. Create two pointers, left and right. Left = pivot + 1, right = array.count - 1<br/>- 5. while left < right<br/>-- 6. Sum up 3 numbers and move the pointer accordingly depends on the comparison. |
|  107  | [Minimum Characters For Words](https://www.algoexpert.io/questions/Minimum%20Characters%20For%20Words)  | [Swift](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/MinimumCharactersForWords.playground/Contents.swift)  | **O(n * I) time, O(c) space**- where n is the number of words, I is the length of the longest word, and c is the number of unique characters across all words. |
|  106  | [Height Balanced Binary Tree](https://www.algoexpert.io/questions/Height%20Balanced%20Binary%20Tree)  | [Swift](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/HeightBalancedBinaryTree.playground/Contents.swift)  | Recursively calculate the left and right subtree heights from each node. determine if the subtree rooted at that node is balanced. If you make it through the entire tree without finding any unbalanced subtrees, and if you determine that the heights of the main two subtrees aren't more than 1 apart, then the entire tree is balanced. |
|  105  | [Non-Constrcutible Change](https://www.algoexpert.io/questions/Non-Constructible%20Change)  | [Swift](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/Non-ConstructibleChange.playground/Contents.swift)  | Create a variable to store the amount of change that you can curerntly create up to. Sort all of your coins, and loop through them in ascending order. At every iteration, compare the current coin to the maount of change that you can currently create up to. |
|  104  | [Tournament Winner](https://www.algoexpert.io/questions/Tournament%20Winner)  | [Swift](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/TournamentWinner.playground/Contents.swift)  | 1. Create a map [String: Int]<br/>2. Loop each competitions and increase winner's point at the map<br/>3. Return the highest score of the team|
|  103  | [Sorted Squared Array](https://www.algoexpert.io/questions/Sorted%20Squared%20Array)  | [Swift](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/SortedSquaredArray.playground/Pages/Pointer-Method.xcplaygroundpage/Contents.swift)  | 2 methods are available and the optimal solution. <br/>1. Create array with the same length of the given array<br/>2. Create pointers for left, right and index<br/>3. Loop while left <= right.<br/> - Fill the array from the back with larger number. <br/> - Move the pointer and index accordingly |
|  102  | [Validate Subsequence](https://www.algoexpert.io/questions/Validate%20Subsequence)  | [Swift](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/ValidateSubsequence.playground/Contents.swift)  | 1.Set sequence index = 0 and final index = sequence.count<br/>2. Increment index<br/> - If sequence == array -> increment both<br/> - If sequence != array -> increment array only<br/>3. If sequence index == sequence.count -> true<br/>**Time O(N), Space O(1)**|
|  101  | [Two Number Sum](https://www.algoexpert.io/questions/Two%20Number%20Sum)  | [Swift](https://github.com/roypark2638/Algorithm-Leetcode/blob/main/TwoNumberSum.playground/Pages/HashMap-Method.xcplaygroundpage/Contents.swift)  | **1. HashMap. Time: O(n), Sapce: O(n)**<br/>**2. Sort and search with two pointers O(n) and O(1) space**|
